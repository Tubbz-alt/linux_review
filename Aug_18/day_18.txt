(int&)a:将a的引用强制转换为整型,意思是a所在的内存，本来定义的时候为float类型并初始为1.0if，
但现在我要按int类型解释这段内存（也就是说a所在的内存地址中的数据本来是按float型存储表示的，你非要按int型来解释不可）。
1.0f   在内存中的存储为
0   011   1111   1   000   0000   0000   0000   0000   0000.
把他按整型数解释为2^29+2^28+2^27+2^26+2^25+2^24+2^23=1065353216

(int&)a 相当于*(int*)&a ，*(int*)(&a)，*((int*)&a)  
(int)a   a在内存中的值转换成int类型   


浮点数在内存中的存储方式
C语言中，对于浮点类型的数据采用单精度类型（float）和双精度类型(double)来存储，float数据占用32bit,
double数据占用64bit,我们在声明一个变量float f= 2.25f的时候，是如何分配内存的呢？
 C语言中浮点数在内存中的存储方式

 C语言中，对于浮点类型的数据采用单精度类型（float）和双精度类型(double)来存储，float数据占用32bit,double数据占用64bit,我们在声明一个变量float f= 2.25f的时候，是如何分配内存的呢？


 float在内存中的存储方式如下图所示：


 double在内存中的存储方式如下图所示：


 无论是单精度还是双精度在存储中都分为三个部分：

 1.符号位(Sign) : 0代表正，1代表为负

 2.指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储

 3.尾数部分（Mantissa）：尾数部分

 首先来看float类型（以2.25为例）

 步骤一：符号位（占1个bit位）的数值

 很容易看出此数为正数，因此符号位为0。

 步骤二：指数位（占8个bit位）的数值

 ***步：先将十进制的2.25转换成二进制0100.01;

 第二步：将100.01用二进制的科学计数法表示为1.001;

 第三步：将第二步所得数值写成指数形式1.001*(2^2);

 第四步：将指数数值2+127=129，将129转化成二进制形式（1000 0001）写到指数部位。

 步骤三：尾数部分（占23个bit位）的数值

 将步骤二第二步中所得的数1.001，小数点后的三位数001写到指数部位，剩下的位用0补齐即可。

 所以单精度浮点数2.25在内存中的表示方式为：

 0 1000 0001 00100000000000000000000

 再来看double类型（还是以2.25为例）

 步骤一：符号位（占1个bit位）的数值

 很容易看出此数为正数，因此符号位为0。

 步骤二：指数位（占11个bit位）的数值

 ***步：先将十进制的2.25转换成二进制0100.01;

 第二步：将100.01用二进制的科学计数法表示为1.001;

 第三步：将第二步所得数值写成指数形式1.001*(2^2);

 第四步：将指数数值2+1023=1025，将129转化成二进制形式（100 0000 0001）写到指数部位。

 步骤三：尾数部分（占52个bit位）的数值

 将步骤二第二步中所得的数1.001，小数点后的三位数001写到指数部位，剩下的位用0补齐即可。

 所以双精度浮点数2.25在内存中的表示方式为：

 0 100 0000 0001 0010000000000000000000000000000000000000000000000000




0 1000 0001 00100000000000000000000




二叉树：

满二叉树在同样深度的二叉树中节点个数最多
叶子节点只能出现在最下一层
只有度为2和度为1的节点

完全二叉树：
在满二叉树上连续去掉任意个节点就是一颗完全二叉树





















